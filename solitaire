#!/usr/bin/env python
# Solitaire
#
from GameView import animation, log, checkTouch, display, initView, wait, touchDeck, touchWaste, touchButton, touchPile 
import Model as model
import pygame
import sys

#
# Controller
#

def move( dest, source, index):
    length = len(dest.cards)
    animation.set( dest=dest, cards=model.getCardsFrom( source, index))
    log.append( ("move", (dest, source, length)))
    # animation loop
    while animation.inMotion():
        display()
        wait( animation.speed)
        # while( not pygame.event.get()): pass   # single step through animation
    # place card(s) in final position then update view
    for card in animation.cards:
        animation.dest.cards.append( card)
    display()
    model.countSteps += 1

def checkMoveToPile( touch):
    if not touch:
        return None
    card = touch.source.cards[ touch.index]
    pile = card.matchPile()
    if pile!=None:
        move( dest=pile, source=touch.source, index=touch.index) 
    return pile

def checkMoveToFoundation( touch):
    if not touch:
        return None
    card = touch.source.cards[touch.index]
    foundation = card.matchFoundation()
    if foundation!=None:
        move( dest=foundation, source=touch.source, index=touch.index)
    return foundation

def undo():
    if log.list:
        action, params  = log.pop()
        if action == "move":
            dest, source, index = params
            move( source, dest, index)      # animate the reverse of the last move
            log.pop()                       # avoid logging the undo action
        elif action == "turn":
            card = params.top()
            undo()                          # move / animate
            card.face = 'D'                 # turn back down
            display()
        elif action == "recycle":
            model.unrecycle()

def userInput():
    'returns a touch tuple, intercepts QUIT'
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        if event.type == pygame.MOUSEBUTTONUP:
            return checkTouch( *pygame.mouse.get_pos())
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                sys.exit()
            if event.key == pygame.K_m:
                return touchWaste()
            if event.key == pygame.K_SPACE:
                return touchDeck()
            if event.key == pygame.K_COMMA:
                return touchButton( 0)
    return []

def startGame():
    global Auto, Victory
    Auto = False
    Victory = False
    model.init()
    model.shuffle()
    model.deal()
    display()
    model.countSteps = 0
    log.clear()

#----------------------------------------------------------------------

if __name__ == "__main__":
    initView()
    startGame()

    # main loop
    while( True):
        wait( animation.speed)
        touch = userInput()

        if Victory:
            choice = selectBox(["Victory", "Start a new Game", "Quit"])
            if choice == 0:
                startGame()
            else:
                sys.exit()

        # auto mode activated
        elif Auto:
            # try to use the top card from the waste
            if model.waste:
                print 'check waste'
                # try to move the card automatically to the first matching foundation
                if checkMoveToFoundation( touchWaste()):
                    Victory = model.checkFinished()

            # try with one of the tips
            for pile in model.piles:
                if pile:
                    print 'check Pile', pile
                    if checkMoveToFoundation( touchPile(pile)):
                        Victory = model.checkFinished()
                            
        # else respond to user input
        elif touch:
            if touch.source.name == "deck":
                if model.deck.cards:
                    # get the top card down into the waste
                    move( dest=model.waste, source=model.deck, index=-1)
                else: # if deck is empty
                    model.recycle()
                    log.append( ("recycle", 0))
                    
            elif touch.source.name == "pile":
                if not checkMoveToFoundation( touch):
                    checkMoveToPile( touch)

            elif touch.source.name == "tail":
                    checkMoveToPile( touch)

            elif touch.source.name == "foundation":
                    checkMoveToPile( touch)

            elif touch.source.name == "waste":
                if not checkMoveToFoundation( touch):
                    checkMoveToPile( touch)

            elif touch.source.name == "button":
                if touch.index == 0:  # undo
                    undo()

                elif touch.index == 1:  # restart
                    model.restart()
                    model.countSteps = 0
                    log.clear()

                elif touch.index == 2:  # re-shuffle and deal a new one
                    startGame()
                    
            display()
            # check if auto can be activated
            if not Auto:
                Auto = ( model.countHidden() < 1)
